{"ast":null,"code":"// We need this to generate random keys both here and later when weâ€™ll map React Components\nimport { nanoid } from \"nanoid\";\nimport NextCors from \"nextjs-cors\"; // Sanitize the html for security reasons\n\nimport sanitizeHtml from \"sanitize-html\";\nimport { writeClient } from \"../../lib/sanityClient\"; // RegEx to identify urls and set the comment as unapproved\n\nconst urlRegEx = new RegExp(\"([a-zA-Z0-9]+://)?([a-zA-Z0-9_]+:[a-zA-Z0-9_]+@)?([a-zA-Z0-9.-]+\\\\.[A-Za-z]{2,4})(:[0-9]+)?([^ ])+\");\nexport default function handler(req, res) {\n  return new Promise(async (resolve, reject) => {\n    await NextCors(req, res, {\n      // Options\n      methods: [\"GET\", \"HEAD\", \"PUT\", \"PATCH\", \"POST\", \"DELETE\"],\n      origin: \"*\",\n      optionsSuccessStatus: 200 // some legacy browsers (IE11, various SmartTVs) choke on 204\n\n    });\n    const document = req.body;\n    console.log(document);\n    document._type = \"comment\";\n    document._key = nanoid();\n    document._id = document._key;\n    document._createdAt = new Date();\n    document._blogId = document.blogId;\n    document.comment = sanitizeHtml(document.comment, {\n      allowedTags: [\"b\", \"i\", \"em\", \"strong\", \"a\", \"li\", \"ul\"],\n      allowedAttributes: {\n        a: [\"href\"]\n      }\n    });\n    if (!document.name) document.name = \"Anonymous\";\n    if (document.comment.match(urlRegEx)) document.approved = false;else document.approved = true;\n\n    try {\n      if (document.parentCommentId) {\n        // Remove these values from the document, as they're not expected in the database\n        const firstParentId = document.firstParentId;\n        const parentCommentId = document.parentCommentId;\n        delete document.parentCommentId;\n        delete document.firstParentId;\n        appendChildComment(firstParentId, parentCommentId, document).then(() => {\n          resolve(res.status(200).json({\n            message: \"Comment Created\"\n          }));\n        });\n      } else {\n        // If there's no parentCommentId, just create a new comment\n        writeClient.create(document).then(() => {\n          resolve(res.status(200).json({\n            message: \"Comment Created\"\n          }));\n        });\n      }\n    } catch (err) {\n      reject(res.status(500).json({\n        message: String(err)\n      }));\n    }\n  });\n}\n\nconst appendChildComment = (firstParentId, parentCommentId, childComment) => {\n  return new Promise(async resolve => {\n    // Get the first level parent comment\n    const query = `*[_type == \"comment\" && _id == \"${firstParentId}\"][0]`;\n    const parentComment = await writeClient.fetch(query);\n\n    if (!parentComment.childComments) {\n      // Parent Comment has no children, just create a new Array with the child comment\n      parentComment.childComments = [childComment];\n    } else if (parentComment._id === parentCommentId) {\n      // Parent Comment is a first level comment, so just append the comment\n      parentComment.childComments = [...parentComment.childComments.filter(c => c._id !== childComment._id), childComment]; // The filter is not necessary right now, but in case you want to add an Edit\n      // functionality, you'll need this.\n    } else {\n      // Parent comment is a level two or more nested comment\n      // We need to find the actual parent comment in all nested comments\n      const childToUpdate = getChildComment(parentComment, parentCommentId);\n\n      if (!childToUpdate.childComments) {\n        // Parent comment has no children, create new Array with the new child\n        childToUpdate.childComments = [childComment];\n      } else {\n        // Parent comment already has some children\n        // Append the new childComment\n        childToUpdate.childComments = [...childToUpdate.childComments.filter(c => c._id !== childComment._id), childComment];\n      }\n    } // Patch the document\n\n\n    writeClient.patch(parentComment._id).set(parentComment).commit().then(() => resolve());\n  });\n};\n\nconst getChildComment = (firstParentComment, childCommentId) => {\n  var _firstParentComment$c;\n\n  let returnComment = null;\n  firstParentComment === null || firstParentComment === void 0 ? void 0 : (_firstParentComment$c = firstParentComment.childComments) === null || _firstParentComment$c === void 0 ? void 0 : _firstParentComment$c.forEach(c => {\n    if (c._id == childCommentId) {\n      returnComment = c;\n    } else if (c.childComments) {\n      returnComment = getChildComment(c, childCommentId);\n    } else {\n      return returnComment;\n    }\n  });\n  return returnComment;\n};","map":null,"metadata":{},"sourceType":"module"}