{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useState, useEffect, createContext } from \"react\";\nimport Comment from \"./SingleComment\";\nimport { writeClient as client } from \"../../lib/sanityClient\";\nconst ReactionsContext = /*#__PURE__*/createContext(undefined);\n\nconst AllComments = ({\n  blogId\n}) => {\n  console.log(blogId);\n  const query = `*[_type == \"comment\" && approved==true && _blogId == \"${blogId}\" ]{_id, comment, name, _createdAt, _blogId, childComments} | order (_createdAt)`;\n  let querySub = undefined;\n  const {\n    0: comments,\n    1: setComments\n  } = useState();\n  useEffect(async () => {\n    setComments(await client.fetch(query)); // Subscribe to the query, listening to new updates\n    // If there's an update, add it to the comments state and sort it again\n    // The update might occur on a comment we already have in the state,\n    // so we should filter out that comment from the previous state\n\n    querySub = client.listen(query).subscribe(update => {\n      if (update) {\n        setComments(comments => [...comments.filter(comment => comment._id !== update.result._id), update.result].sort((a, b) => a._createdAt > b._createdAt ? 1 : -1));\n        console.log(comments);\n      }\n    }); // Unsubscribe on Component unmount\n\n    return () => {\n      querySub.unsubscribe();\n    };\n  }, [querySub]);\n  return /*#__PURE__*/_jsx(\"ul\", {\n    children: comments === null || comments === void 0 ? void 0 : comments.map(comment => /*#__PURE__*/_jsx(Comment, {\n      comment: comment,\n      firstParentId: comment.firstParentId || comment._id\n    }, comment._id))\n  });\n};\n\nexport default AllComments;\nexport { ReactionsContext };","map":null,"metadata":{},"sourceType":"module"}