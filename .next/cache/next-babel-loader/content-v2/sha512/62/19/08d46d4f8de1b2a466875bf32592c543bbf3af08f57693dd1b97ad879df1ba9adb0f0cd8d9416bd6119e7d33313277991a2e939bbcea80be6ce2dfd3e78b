{"ast":null,"code":"import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useState, useEffect, useContext } from \"react\";\nimport axios from \"axios\";\nimport { nanoid } from \"nanoid\";\nimport EmojiWithCounter from \"./EmojiWithCounter\"; // import getKey from \"../../lib/keyGen\";\n\nimport EmojiAdder from \"./EmojiAdder\";\nimport { ReactionsContext } from \"../Comments\";\nimport { writeClient as client } from \"../../../lib/sanityClient\";\nimport { DEFAULT_EMOJI_OPTIONS } from \"../../../lib/emojiConfig\";\nlet dbDebouncerTimer;\n\nconst ReactionBlock = ({\n  commentId\n}) => {\n  var _useContext, _useContext$filter$ma;\n\n  // We get the initial reactions we previously fetched from the Context\n  const contextReactions = (_useContext = useContext(ReactionsContext)) === null || _useContext === void 0 ? void 0 : (_useContext$filter$ma = _useContext.filter(r => r.commentId === commentId).map(r => r.reactions)) === null || _useContext$filter$ma === void 0 ? void 0 : _useContext$filter$ma.sort((a, b) => a.counter < b.counter ? 1 : -1)[0];\n  const {\n    0: reactions,\n    1: setReactions\n  } = useState([]);\n  const {\n    0: shouldUpdateDb,\n    1: setShouldUpdateDb\n  } = useState(false);\n  let querySub = undefined;\n  useEffect(() => {\n    // If there are reactions in the context, set them\n    if (contextReactions) setReactions(contextReactions); // Subscribe to the query Observable and update the state on each update\n\n    const query = `*[_type == \"commentReactions\" && commentId==\"${commentId}\"]`;\n    querySub = client.listen(query).subscribe(update => {\n      if (update) {\n        setReactions([...update.result.reactions.sort((a, b) => a.counter < b.counter ? 1 : -1)]);\n      }\n    }); // Unsubscribe on Component unmount\n\n    return () => {\n      querySub.unsubscribe();\n    };\n  }, []);\n  useEffect(() => {\n    if (shouldUpdateDb) updateReactionsOnDatabase();\n    setShouldUpdateDb(false);\n  }, [shouldUpdateDb]); // Onclick, update the emoji counter and start a timer to update the database\n\n  const updateEmojiCount = emoji => {\n    setShouldUpdateDb(false);\n    let emojiFromState = reactions.filter(em => em.emoji === emoji)[0];\n\n    if (!emojiFromState) {\n      emojiFromState = DEFAULT_EMOJI_OPTIONS.filter(em => em.emoji === emoji)[0];\n      emojiFromState.counter = 1;\n      setReactions(reactions => [...reactions, emojiFromState].sort((a, b) => a.counter < b.counter ? 1 : -1));\n    } else {\n      emojiFromState.counter++;\n      setReactions(reactions => [...reactions.filter(rea => rea.emoji !== emojiFromState.emoji), emojiFromState].sort((a, b) => a.counter < b.counter ? 1 : -1));\n    }\n\n    setShouldUpdateDb(true);\n  }; // Debouncer to avoid updating the database on every click\n\n\n  const updateReactionsOnDatabase = () => {\n    clearTimeout(dbDebouncerTimer);\n    dbDebouncerTimer = setTimeout(() => {\n      axios.post(\"/api/addReaction\", {\n        commentId: commentId,\n        reactions: reactions\n      });\n      dbDebouncerTimer = null;\n    }, 1000 * 1);\n  };\n\n  const mappedReactions = reactions.map(reaction => /*#__PURE__*/_jsx(EmojiWithCounter, {\n    emoji: reaction.emoji,\n    emojiLabel: reaction,\n    initialCounter: reaction.counter,\n    onIncrease: updateEmojiCount\n  }, nanoid()));\n  return /*#__PURE__*/_jsxs(\"div\", {\n    className: \"reaction-block\",\n    children: [mappedReactions, /*#__PURE__*/_jsx(EmojiAdder, {\n      selectedEmojis: reactions,\n      updateEmojiCount: updateEmojiCount,\n      EMOJI_OPTIONS: DEFAULT_EMOJI_OPTIONS\n    })]\n  });\n};\n\nexport default ReactionBlock;","map":null,"metadata":{},"sourceType":"module"}